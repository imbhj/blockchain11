## 8.counter.html 증가 흐름

1. 증가 버튼을 누른다

2. this.setLoading("increment") 메서드가 호출된다.

```jsx
    // action : "increment" | "decrement"
    setLoading(action) {
        this.setState({ isLoading: true, action })

        setTimeout(() => {
            this.setState({ isLoading: false});
        }, 1000)
    }
```

- isLoading
- action

이 때, isLoading의 상태 변경과 action에 행동 값을 리액트에게 상태 알려줌

3. render()메서드 호출

화면 그림

```jsx
    render() {
        if (this.state.isLoading) return <h1>로딩 중...</h1>
        return (
            <div>
                <p>Counter : {this.state.value}</p>
                <button onClick={() => this.setLoading("increment")}>+</button>
                <button onClick={() => this.setLoading("decrement")}>-</button>
            </div>
        )
    }
```

isLoading의 상태에 따라서 두 개의 분기점으로 나뉜다.

3-1. `this.state.isLoading` 상태가 true일 때, 로딩 중 화면 출력
3-2. `this.state.isLoading` 상태가 flase일 때 증가, 감소 버튼 그리고 숫자 출력

지금은 로딩 중...화면이 출력된다.

4. componentDidUpdate() 메서드 호출

```jsx
    componentDidUpdate(prevProps, prevState, snapShot) {
        console.log("prevState", prevState);
        // 로딩이 끝났을 때 실행 => prevState 즉 이전 상태를 파악
        // 값을 증가 및 감소 시킬거임.
        if (prevState.isLoading && !this.state.isLoading) {
            if(prevState.action === "increment") {
                this.setState({ value: prevState.value + 1});
            } else {
                this.setState({ value: prevState.value - 1});
            }
        }
    }
```

### if (prevState.isLoading && !this.state.isLoading) 조건문

1. 이전 상태 (`prevState.isLoading`)가 `true` 였고,
2. 현재 상태 (`this.state.isLoading`)이 `false` 였다면
=> 즉, `로딩이 끝난 순간` 에만 `setState()` 를 실행하도록 보장.
=> 현재는 로딩이 아직 안끝났으니 조건문 패스

5. componentDidUpdate호출이 끝나면 다시 setLoading(action)메서드
스코프로 돌아온다. 1초 뒤에 로딩의 상태를 false로 변경

```jsx
    // action : "increment" | "decrement"
    setLoading(action) {
        this.setState({ isLoading: true, action })

        setTimeout(() => {
            this.setState({ isLoading: false});
        }, 1000)
    }

```

6. render() 메서드 재호출

```jsx
    render() {
        if (this.state.isLoading) return <h1>로딩 중...</h1>
        return (
            <div>
                <p>Counter : {this.state.value}</p>
                <button onClick={() => this.setLoading("increment")}>+</button>
                <button onClick={() => this.setLoading("decrement")}>-</button>
            </div>
        )
    }
```

이 때, isLoading은 false이니, 로딩 화면이 아닌 카운터 화면이 출력됨.

7. componentDidUpdate() 메서드 호출

```jsx
    componentDidUpdate(prevProps, prevState, snapShot) {
        if (prevState.isLoading && !this.state.isLoading) {
            if(prevState.action === "increment") { 
                this.setState({ value: prevState.value + 1});
            } else {
                this.setState({ value: prevState.value - 1});
            }
        }
    }
```

### if (prevState.isLoading && !this.state.isLoading) 조건문

`로딩이 끝난 순간` 에만 `setState()` 를 실행하도록 보장.
=> 현재는 로딩이 끝났으니 조건문의 코드를 실행
=> 전의 상태 중, action값이 "increment" 면 값 + 아니면 -

7. render() 메서드 호출

```jsx
    render() {
        if (this.state.isLoading) return <h1>로딩 중...</h1>
        return (
            <div>
                <p>Counter : {this.state.value}</p>
                <button onClick={() => this.setLoading("increment")}>+</button>
                <button onClick={() => this.setLoading("decrement")}>-</button>
            </div>
        )
    }
```

8. 최종적으로 증가된 `value` 가 반영됨 (componentDidUpdate호출)

setState()는 비동기적으로 실행되므로 value가 바로 업데이트되지 않을 수도 있음.  
증가된 값이 반영되려면, 다음 render()에서 상태가 업데이트된 후 확인 가능!
