# 왜 체인일까?

## 1. 정말 필요한가? 블록끼리 연결?

블록 하나만 보자면,  
이미 그 안에는 우리가 원하는 정보가 모두 들어있습니다.

- 거래 데이터
- 타임스탬프
- 해시값 등등…

> 그런데 굳이 왜 **이전 블록의 해시값(previousHash)** 까지 들고 다닐까요?

## 2. 정답은 "연결"이 아닌, **신뢰의 축적**

단일한 블록은 ‘현재 상태’를 보여줄 수는 있어도  
그게 **정상적인 흐름 속에서 만들어졌는지**를 보장하진 못합니다.

> 우리는 데이터를 '기록'하려는 게 아니라,  
> **'신뢰할 수 있는 기록'을 만들고 싶은 것**입니다.

## 3. 블록체인의 핵심 질문

> “이 데이터가 조작되지 않았다는 걸 어떻게 증명할 수 있을까?”

이 질문에 대한 **비트코인의 철학적 대답**은 다음과 같았습니다:

> "이전 기록을 계속 참조하면서 이어 붙이면,  
>  중간 하나만 조작해도 **전체가 깨지게 설계할 수 있다**."

## 4. 그래서 나온 구조: Chain (사슬)

각 블록이 바로 앞 블록의 해시값을 기억합니다:

```ts
block.previousHash === 이전 블록의 hash
```

즉, 이 연결은 단순한 링크가 아니라  
**"과거에 대한 증거"** 이자  
**"변조 방지를 위한 자물쇠"** 역할을 합니다.

## 5. 한 블록만 바꾸면?

만약 누군가 체인의 중간 블록을 조작하면?

- 그 블록의 해시값이 바뀜
- 다음 블록의 `previousHash`와 불일치
- 이후 블록 전부가 **무효** 처리됨

> 하나를 바꾸면 전체가 깨지는 구조  
> → 그래서 **Chain**입니다.

## 6. 단순 연결이 아닌, **시간 순서로 쌓이는 신뢰**

- 블록이 많아질수록 조작은 더 어려워짐
- 긴 체인일수록 "더 신뢰할 만한 역사"

이건 기술적으로는 “데이터 구조”이지만,  
철학적으로는 **시간을 기준으로 쌓이는 신뢰의 역사**입니다.

## 오늘 수업의 진짜 목표

오늘 우리는 체인을 단순히 "Block[] 배열"로 구현하는 게 아닙니다.  
우리는 지금부터 블록체인이라는 시스템이  
**어떻게 신뢰를 시간 순으로 축적하는가**를 체험합니다.
