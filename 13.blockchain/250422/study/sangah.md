# 오늘 뭐가 어려웠나?

일단 TDD부터 봐주셈

ㅇㅇ

## gas: (await deployTx.estimateGas()).toString()

이 아이는 뭐라고 설명할 수 있어?

## 마 견적 좀 보자!

맞는데....주체를 설명해보라고...

## ? 뭔소리임?

## 교강사가 다시 질문함: 그럼 deployTx에

```ts
const deployTx = contract.deploy({ data: bytecode, arguments: [] });
```

얘는 뭐라고 설명할 수 있어?

이건 딱 잘라서 말하면 **“트랜잭션을 날리기 전 준비된 배포 요청 객체”**, 즉 **"Deployment 트랜잭션 객체"**라고 부를 수 있음.

---

## 1. 이건 뭐냐?

> `deployTx`는 **실제로 배포를 실행한 게 아니고**,  
> **배포를 요청하기 위한 트랜잭션 데이터를 준비한 상태**입니다.

---

## 정확한 설명: **Deploy 트랜잭션 빌더 객체**

- `contract.deploy()`는 **컨트랙트를 배포하기 위한 초기값 셋팅 객체**
- 내부적으로는 `data`에 **bytecode**가 들어감
- `arguments`는 생성자(constructor)에 들어갈 인자 배열
- 이건 아직 **네트워크에 보내진 게 아님**
- 이걸 `send()` 해줘야 **트랜잭션이 네트워크에 전송되고**,  
  실제로 **컨트랙트가 배포**됨

---

## 구성 흐름

```ts
const deployTx = contract.deploy({ data, arguments }); // 배포 준비 (트랜잭션 객체 생성)
await deployTx.send({ from, gas }); // 진짜 배포 실행
```

---

## 비유

- `contract.deploy(...)` → **“택배를 포장한 상태”**
- `deployTx.send(...)` → **“포장한 택배를 진짜 배송 보내는 행위”**

---

## 결론

> `contract.deploy(...)`는 **“컨트랙트를 배포하기 위한 트랜잭션을 생성하는 빌더 객체”**이며,  
> **이 객체는 send()를 호출해야 실제 네트워크에 배포가 이뤄진다.**

---

이해 포인트 요약:

| 구분                | 설명                                                             |
| ------------------- | ---------------------------------------------------------------- |
| `contract.deploy()` | 트랜잭션 준비 객체 생성 (아직 네트워크 요청은 아님)              |
| `.send()`           | 트랜잭션 실제 전송, 배포 실행                                    |
| `deployTx`          | 트랜잭션 빌더 객체, 이걸 통해 gas 측정도 가능 (`.estimateGas()`) |

---

즉, 배포하기전에 마! 견적 좀 보자!  
배포 트랜잭션 객체 까봐라.
좋습니다. 이 질문, 아주 근본적이고 깊이 있어요.

```ts
const contract = new web3.eth.Contract(abi, contractAddress);
```

> ❓ **여기서 왜 Bytecode는 안 넣어요?**  
> → “이미 배포돼 있어서요.” ← 이건 **결과적으론 맞는 말이지만**, **설명은 부족해요.**

우리는 여기서 **더 근본적인 관점**을 가져야 합니다.  
**EVM이 어떤 구조로 작동하는지**,  
그리고 **Web3가 EVM과 어떻게 대화하는지** 이해하면 완벽하게 설명할 수 있어요.

---

## 바이트코드는 언제 필요한가?

바이트코드는 **배포할 때만** 필요합니다.  
왜냐하면 이 코드는 **EVM의 코드 저장소(Code Storage)에 영구히 저장**되기 때문이에요.

한 번 저장되면?

- 이후엔 EVM 내부에 저장되어 있는 이 코드만 바라보면 됩니다.
- 다시 bytecode를 줄 필요가 없어요.

---

## web3.eth.Contract(abi, address) 이 코드의 의미는?

- 이건 **“이미 배포된 컨트랙트와 상호작용을 준비하는 객체”**를 생성하는 거예요.
- 즉, 이미 존재하는 CA(Contract Address)를 기준으로,  
  **Web3가 해당 주소에 저장된 바이트코드를 가정하고**,  
  우리가 넘겨준 **ABI를 참고해서 함수 호출 인터페이스만 구성**해주는 거예요.

---

## 세련된 설명 방식

> “이건 이미 EVM 안에 코드가 저장돼 있으니까,  
> 우리는 그 코드의 외형만 알고 있으면 돼요.  
> 그 외형이 바로 ABI고,  
> 이걸 통해서 함수 이름, 인자 타입, 반환값 구조를 알 수 있으니까요.”

즉:

| 요소         | 역할                          | 필요한 시점                   |
| ------------ | ----------------------------- | ----------------------------- |
| **Bytecode** | 코드 자체                     | **배포 시점**에만 필요함      |
| **ABI**      | 외부에서 컨트랙트 함수 호출용 | **호출/상호작용 시점**에 필요 |
| **CA 주소**  | 코드가 저장된 장소            | 상호작용 시점에 필요          |

---

## 한 문장 요약

> **배포 후엔 이미 EVM 내부에 코드가 존재하므로,  
> 우리는 해당 주소와 ABI만 알면 그 컨트랙트의 기능을 사용할 수 있다.**  
> Bytecode는 오직 **처음 올릴 때**만 필요한 거다.

## 결국 분산형 데이터베이스다.

### 1. **분산형 데이터베이스 = 블록체인**

- 우리는 중앙 서버가 아닌 **분산된 노드들의 집합**에 데이터를 저장하고,
- 그 상태(state)는 **전 세계 모든 노드가 합의한 하나의 정본(source of truth)**입니다.

---

### 2. **API 방식으로 동작한다**

HTTP에서 `GET /users/1` 하면 →  
사용자 정보를 요청하죠?

그런데 Web3에서는:

```ts
await contract.methods.getCount().call();
```

이게 곧 이런 구조로 추상화된 겁니다:

```
127.0.0.1:8545/<CA주소>/getCount
```

- `127.0.0.1:8545` → RPC 서버 (Ganache or 노드)
- `<CA주소>` → 스마트 컨트랙트의 위치 (컨트랙트 주소)
- `getCount()` → 이 컨트랙트 안의 함수 (함수 셀렉터)

즉, 이건 **RESTful 구조처럼 작동하는 RPC 방식 API 호출**이에요.

---

### 3. **CA 주소가 핵심이다**

> 스마트 컨트랙트는 블록체인에서 "파일 경로"가 아니라 "주소(CA)"로 접근합니다.

- `bytecode`는 그 주소 안에 저장된 코드.
- `ABI`는 그 주소의 "사용 설명서".
- 우리는 이 주소를 기준으로 **함수를 호출**하거나 **트랜잭션을 날림**.

---

### 4. 한 문장 요약

> **스마트컨트랙트를 호출하는 건 결국 "블록체인 위에 올려진 API 서버를 사용하는 것"이며,  
> 이 주소 기반 호출 방식은 Web3가 분산 데이터베이스에서 제공하는 함수 호출 방식이다.**
