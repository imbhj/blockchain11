## 저번 시간에는 뭘했을까?

자바스크립트의 프로토타입

## 저번 시간의 핵심

`본질`과 `분류` 그리고 추상화

- 특정한 사물을 만들기 위해 우리는 먼저 "추상화"를 합니다.
- 예: 파란 의자, 빨간 의자, 노란 의자 → 본질은 "의자(a chair)"입니다.
- 프로토타입은 객체 지향 프로그래밍에서 본질적인 특성을 다른 객체가 상속받도록 설계된 메커니즘입니다.

class chair {} => 추상화된 본질적인 물질

const blueChair = new chair();

- 자바스크립트의 프로토타입을 이해함으로써, 객체 생성과 상속 구조를 명확히 파악할 수 있습니다.(파악하여야 한다.)

## 저번 시간의 목차

- 함수형 프로그래밍
- 객체 지향 프로그래밍
- 프로토타입 기반 객체 생성
- 상속
- 생성자 함수와 클래스 => class
- this 바인딩

### **이번 시간에는 뭐할까?**  

**비동기 프로그래밍**  

비동기에 대한 설명은 Node.js 첫날 배웠던 내용이죠?  
기억이 희미할 수 있으니 간단히 다시 설명드리겠습니다

- 기존 코드 실행은 **위에서 아래로, 순차적으로 실행**되었죠?  
- 한 가지 작업이 끝난 후에야 다음 작업이 실행되는 방식, 즉 **동기적 사고 방식**입니다.  
- 그러나 **비동기적 사고 방식**에서는, 특정 작업을 요청한 후 그 결과를 기다리지 않고도 다른 작업을 처리할 수 있습니다.  

**왜 필요할까?**  

- 어떤 작업은 처리에 **시간이 오래 걸릴 수 있다**는 점을 인지해야 합니다.
- 우리가 특정 작업을 요청했을 때, 결과를 기다리는 동안 **다른 작업도 병행할 수 있어야 효율적**입니다.  

### **이번 시간의 핵심**  

비동기 프로그래밍이 왜 필요할까요?

우리가 어떤 작업의 처리 시간을 예측할 수 없는 상황이라면,
그 작업을 효율적으로 관리하고 제어하고 싶어지겠죠.

예를 들어, A와 B라는 두 개의 데이터 요청이 있다고 가정해봅시다

A는 더 빨리 응답할 수 있는 요청입니다.
하지만 실제로는 B를 먼저 요청하고, A를 나중에 요청한다고 해도 결과는 변하지 않습니다.
그렇다면, A가 먼저 응답을 받은 후에 B의 응답을 기다리도록 조정하고 싶을 때가 있겠죠?
이처럼 `비동기적인 코드를 동기적으로 처리하고 싶은 상황`이 비동기 프로그래밍의 핵심입니다.

따라서 오늘 우리는 **왜 비동기 프로그래밍이 필요한지**를 구체적으로 이해하고,  
이를 해결하기 위해 사용할 수 있는 **방법**을 배웁니다.  

1. **Callback**: 가장 기본적인 비동기 처리 방식  
2. **Promise**: Callback Hell 문제를 해결하기 위한 패턴  
3. **Async/Await**: 비동기 코드를 동기처럼 읽기 쉽게 만드는 최신 문법  
4. **Promise.all()**: 여러 비동기 작업을 병렬로 처리하는 방법  

### **이번 시간의 목차**  

1. **비동기 프로그래밍의 개념**  

   - 비동기 프로그래밍이 필요한 이유  

2. **Callback Hell**  

   - 콜백 패턴의 작동 방식  
   - 콜백 지옥이 발생하는 이유  

3. **Promise**  

   - Promise 객체의 구조와 상태 관리 (pending, fulfilled, rejected)  
   - `then`, `catch`, `finally`를 통한 체이닝  

4. **Async/Await**  

   - Async/Await의 기본 문법  
   - 동기적으로 보이는 비동기 코드 작성  